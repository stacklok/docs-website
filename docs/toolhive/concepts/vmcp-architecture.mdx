---
title: Virtual MCP architecture
description:
  Understanding what Virtual MCP Server does, why it exists, and when to use it.
---

This document explains Virtual MCP Server (vMCP), why it exists, and when you
should use it. You'll learn how vMCP simplifies managing multiple MCP servers
and enables powerful multi-system workflows.

## The problem vMCP solves

**Before vMCP**: Engineers manage 10+ separate MCP server connections, each with
its own authentication, manually coordinate multi-step workflows across systems,
and repeatedly configure the same parameters.

**With vMCP**: Connect once to a unified endpoint that aggregates all backends,
execute complex multi-system workflows declaratively, and use pre-configured
tools with sensible defaults.

## Core value propositions

Virtual MCP Server delivers four key benefits:

1. **Reduce complexity**: 10 connections become 1 connection (90% reduction in
   configuration)
2. **Speed up workflows**: Parallel execution makes multi-system tasks 5-10x
   faster
3. **Improve security**: Centralized authentication and authorization with a
   two-boundary model
4. **Enable reusability**: Define workflows once, use them everywhere

## Key capabilities

### Multi-server aggregation

Managing 10-20+ MCP server connections is overwhelming. Each server needs its
own configuration, authentication, and maintenance. vMCP aggregates all backends
into one endpoint with automatic conflict resolution.

**Example scenario**: An engineering team needs access to 8 backend servers
(GitHub, Jira, Slack, Confluence, PagerDuty, DataDog, AWS, Internal Docs).
Instead of configuring 8 separate connections, they configure one vMCP
connection with SSO. The result is 87% less configuration complexity and easier
onboarding for new team members.

When multiple backends have tools with the same name (for example, both GitHub
and Jira have `create_issue`), vMCP automatically prefixes them:
`github_create_issue`, `jira_create_issue`. You can also define custom names for
clarity.

### Multi-step workflows (composition)

Real-world tasks span multiple systems and require manual orchestration. vMCP
lets you define declarative workflows with parallel execution, conditionals,
error handling, and human-in-the-loop approval gates.

**Example scenario**: During an incident investigation, you need logs from your
logging system, metrics from your monitoring platform, traces from your tracing
service, and infrastructure status from your cloud provider. With vMCP, you
fetch all of this in parallel (4x faster than sequential), automatically
aggregate it into a formatted report, and create a Jira ticket with all the
data. This workflow is reusable for every incident.

**Example scenario**: For a PR deployment, you might want to merge the PR, wait
for tests, ask a human for approval, deploy only if approved, and notify Slack.
vMCP handles this entire flow declaratively, with automatic rollback on
deployment failure.

### Tool customization and overrides

Third-party MCP servers often have generic names, descriptions, and unrestricted
parameters. vMCP lets you filter, rename, and wrap tools without modifying the
upstream servers.

**Security policy enforcement**: You can restrict a fetch tool to internal
domains only (`*.company.com`), validate URLs before calling the backend, and
provide clear error messages for policy violations.

**Simplified interfaces**: A complex tool like AWS EC2 might have 20+
parameters, but your frontend team only needs 3. You can create a simplified
wrapper that uses instance names instead of IDs and pre-fills safe defaults for
all other parameters.

### Parameter defaults and pre-configuration

Generic servers require repetitive parameter specification. You always use the
same repo, channel, or database. vMCP lets you create specialized instances with
pre-configured defaults.

**Example scenario**: All GitHub queries for your team should default to the
`stacklok/toolhive` repo. Engineers never need to specify the repo parameter,
and they can't accidentally query the wrong repository.

**Example scenario**: Staging database is the default (safe for development),
while production queries require an explicit approval gate. Connection details
are centralized in the vMCP configuration.

### Authentication boundary separation

Different auth is needed for clients versus backends, and managing credentials
across multiple systems is complex. vMCP implements a two-boundary auth model
where clients use SSO and vMCP handles per-backend authentication.

**How it works**: Engineers authenticate once with your identity provider (Okta,
Google, Microsoft Entra ID). vMCP exchanges their token for backend-specific
tokens (GitHub, Jira, Slack), each with appropriate scopes. Revoking access is
simple: disable the user in your IdP and all backend access is revoked
instantly.

This approach provides single sign-on for users, least-privilege token scoping
per backend, centralized access control, and a complete audit trail.

## When to use vMCP

### Good fit

- Teams managing 5+ MCP servers
- Tasks requiring coordination across multiple systems
- Centralized authentication and authorization requirements
- Workflows that should be reusable across the team
- Security policies that need centralized enforcement

### Not needed

- Single MCP server usage
- Simple, one-step operations
- No orchestration requirements

## Summary

Virtual MCP Server transforms MCP from individual servers into a unified
orchestration platform. The use cases range from simple aggregation (90% less
configuration) to complex workflows with approval gates (5-10x faster
execution), making it valuable for organizations at any scale.

## Related information

- [Deploy Virtual MCP Server](../guides-vmcp/intro.mdx)
- [Tool aggregation and conflict resolution](../guides-vmcp/tool-aggregation.mdx)
- [Authentication](../guides-vmcp/authentication.mdx)
- [Composite tools and workflows](../guides-vmcp/composite-tools.mdx)
