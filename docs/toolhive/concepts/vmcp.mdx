---
title: Understanding Virtual MCP Server
sidebar_label: Virtual MCP Server (vMCP)
description:
  Learn what Virtual MCP Server does, why it exists, and when to use it.
---

This document explains Virtual MCP Server (vMCP), a feature of the ToolHive
Kubernetes Operator. You'll learn why it exists, when to use it, and how it
simplifies managing multiple MCP servers while enabling powerful multi-system
workflows.

## The problem vMCP solves

**Before vMCP**: Engineers manage 10+ separate MCP server connections, each with
its own authentication, manually coordinate multi-step workflows across systems,
and repeatedly configure the same parameters.

**With vMCP**: Connect once to a unified endpoint that aggregates all backend
MCP servers, execute complex multi-system workflows declaratively, and use
pre-configured tools with sensible defaults.

## Core value propositions

vMCP delivers four key benefits:

1. **Reduce complexity**: Many connections become one, dramatically simplifying
   configuration
2. **Speed up workflows**: Parallel execution across systems instead of
   sequential calls
3. **Improve security**: Centralized authentication and authorization with a
   two-boundary model
4. **Enable reusability**: Define workflows once, use them everywhere

## Key capabilities

### Multi-server aggregation

Managing 10-20+ MCP server connections is overwhelming. Each server needs its
own configuration, authentication, and maintenance. vMCP aggregates all backend
MCP servers into one endpoint with automatic conflict resolution.

vMCP supports two types of backends:

- **MCPServer**: Container-based MCP servers running in your Kubernetes cluster
- **MCPRemoteProxy**: Proxies to external remote MCP servers (SaaS platforms,
  third-party services, or MCP servers hosted outside your cluster)

:::note MCPRemoteProxy support

MCPRemoteProxy support in vMCP is currently in development. vMCP can discover
MCPRemoteProxy backends, but authentication between vMCP and MCPRemoteProxy is
not yet fully implemented. MCPServer backends work fully with vMCP.

:::

This architecture enables combining internal tools with external SaaS MCP
endpoints in a single unified interface.

**Example scenario**: An engineering team needs access to 8 backend servers
(GitHub, Jira, Slack, Confluence, PagerDuty, Datadog, AWS, and internal company
docs). Some are container-based MCPServer resources running in the cluster,
while others are remote SaaS MCP endpoints accessed via MCPRemoteProxy. Instead
of configuring 8 separate connections, they configure one vMCP connection with
SSO. This significantly reduces configuration complexity and makes onboarding
new team members much easier.

When multiple backend MCP servers have tools with the same name (for example,
both GitHub and Jira have `create_issue`), vMCP automatically prefixes them:
`github_create_issue`, `jira_create_issue`. You can also define custom names for
clarity.

### Multi-step workflows (composition)

Real-world tasks span multiple systems and require manual orchestration. vMCP
lets you define declarative workflows with parallel execution, conditionals,
error handling, and human-in-the-loop approval gates.

**Example scenario**: During an incident investigation, you need logs from your
logging system, metrics from your monitoring platform, traces from your tracing
service, and infrastructure status from your cloud provider. Without vMCP, an
engineer manually runs 4 commands sequentially and aggregates results. With
vMCP, you fetch all of this in parallel, automatically aggregate it into a
formatted report, and create a Jira ticket with all the data. This workflow is
reusable for every incident.

**Example scenario**: For an app deployment, merge the pull request, wait for
tests, ask a human for approval, deploy only if approved, and notify the team in
Slack. vMCP handles this entire flow declaratively, with automatic rollback on
deployment failure.

### Tool customization and overrides

Third-party MCP servers often have generic names, descriptions, and unrestricted
parameters. vMCP lets you filter, rename, and wrap tools without modifying the
upstream servers.

**Security policy enforcement**: You can restrict a fetch tool to internal
domains only (`*.company.com`), validate URLs before calling the backend, and
provide clear error messages for policy violations.

**Simplified interfaces**: A complex tool like AWS EC2 might have 20+
parameters, but your frontend team only needs 3. You can create a simplified
wrapper that uses instance names instead of IDs and pre-fills safe defaults for
all other parameters.

### Parameter defaults and pre-configuration

Generic servers require repetitive parameter specification. You always use the
same repo, channel, or database. vMCP lets you create specialized instances with
pre-configured defaults.

**Example scenario**: Without vMCP, every GitHub query requires specifying
`repo: stacklok/toolhive`. With vMCP, you pre-configure this default - engineers
never specify the repo parameter, and they can't accidentally query the wrong
repository. This eliminates hundreds of repetitive parameter entries per week.

**Example scenario**: Configure staging database as the default (safe for
development), while production queries require an explicit approval gate.
Connection details are centralized in vMCP configuration instead of scattered
across individual tool configurations.

### Authentication boundary separation

Different authentication is needed for clients versus backend MCP servers, and
managing credentials across multiple systems is complex. vMCP implements a
two-boundary auth model that separates these concerns.

**How it works**: Clients authenticate to vMCP using OAuth 2.1 authorization as
defined in the MCP specification. vMCP then handles authentication to each
backend MCP server independently. Revoking access is simple: disable the user in
your identity provider and all backend access is revoked instantly.

This approach provides single sign-on for users, centralized access control, and
a complete audit trail.

## When to use vMCP

### Good fit

- Teams managing 5+ MCP servers (local or remote)
- Tasks requiring coordination across multiple systems
- Centralized authentication and authorization requirements
- Workflows that should be reusable across the team
- Security policies that need centralized enforcement
- Aggregating external SaaS MCP servers with internal tools

### Not needed

- Single MCP server usage
- Simple, one-step operations
- No orchestration requirements

## Summary

vMCP transforms MCP from individual servers into a unified orchestration
platform. It aggregates both container-based MCPServer resources and remote
MCPRemoteProxy backends into a single endpoint. The use cases range from simple
aggregation to complex workflows with approval gates, making it valuable for
teams managing multiple MCP servers.

## Related information

- [Deploy vMCP](../guides-vmcp/intro.mdx)
- [Configure authentication](../guides-vmcp/authentication.mdx)
- [Tool aggregation and conflict resolution](../guides-vmcp/tool-aggregation.mdx)
- [Composite tools and workflows](../guides-vmcp/composite-tools.mdx)
- [Proxy remote MCP servers](../guides-k8s/remote-mcp-proxy.mdx)
