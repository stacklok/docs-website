---
title: Authentication
description: Configure client and backend authentication for Virtual MCP Server.
---

Virtual MCP implements a two-boundary authentication model that separates client
authentication from backend authentication, giving you centralized control over
access while supporting diverse backend requirements.

## Two-boundary authentication model

```mermaid
flowchart LR
    subgraph Boundary1[" "]
        direction TB
        Client[MCP Client]
        B1Label["**Boundary 1**<br>Client → Virtual MCP"]
    end

    subgraph vMCP[Virtual MCP Server]
        Auth[Token Validation]
        Backend[Backend Auth]
    end

    subgraph Boundary2[" "]
        direction TB
        B2Label["**Boundary 2**<br>Virtual MCP → Backend APIs"]
        GitHub[GitHub API]
        Jira[Jira API]
    end

    Client -->|"vMCP-scoped token"| Auth
    Auth --> Backend
    Backend -->|"Backend-scoped token"| GitHub
    Backend -->|"Backend-scoped token"| Jira
```

**Boundary 1 (Incoming):** Clients authenticate to Virtual MCP using the
mechanism defined in the MCP specification. This is your organization's identity
layer.

**Boundary 2 (Outgoing):** Virtual MCP obtains appropriate credentials for each
backend. Each backend API receives a token or credential scoped to its
requirements.

## Incoming authentication

Configure how clients authenticate to Virtual MCP.

### Anonymous (development only)

No authentication required. Use only for local development.

```yaml
spec:
  incomingAuth:
    type: anonymous
```

:::warning

Never use `anonymous` incoming authentication in production environments.

:::

### OIDC authentication

Validate tokens from an external identity provider:

```yaml
spec:
  incomingAuth:
    type: oidc
    oidcConfig:
      type: inline
      inline:
        issuer: https://auth.example.com
        clientId: your-client-id
        audience: vmcp
```

When using an identity provider that issues opaque OAuth tokens, add a
`clientSecretRef` referencing a Kubernetes Secret to enable token introspection:

```yaml
spec:
  incomingAuth:
    type: oidc
    oidcConfig:
      type: inline
      inline:
        issuer: https://auth.example.com
        clientId: your-client-id
        audience: vmcp
        clientSecretRef:
          name: oidc-client-secret
          key: clientSecret
```

Create the Secret:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: oidc-client-secret
  namespace: toolhive-system
type: Opaque
stringData:
  clientSecret: your-client-secret
```

### Kubernetes service account tokens

Authenticate using Kubernetes service account tokens for in-cluster clients:

```yaml
spec:
  incomingAuth:
    type: oidc
    oidcConfig:
      type: kubernetes
      kubernetes:
        audience: toolhive
```

This configuration uses the Kubernetes API server as the OIDC issuer and
validates service account tokens. The defaults work for most clusters:

- **issuer**: `https://kubernetes.default.svc` (auto-detected)
- **audience**: `toolhive` (configurable)

## Outgoing authentication

Configure how Virtual MCP authenticates to backend MCP servers.

### Discovery mode

When using discovery mode, Virtual MCP checks each backend MCPServer's
`externalAuthConfigRef` to determine how to authenticate. If a backend has no
auth config, Virtual MCP connects without authentication.

```yaml
spec:
  outgoingAuth:
    source: discovered
```

This is the recommended approach for most deployments. Backends that don't
require authentication work automatically, while backends with
`externalAuthConfigRef` configured use their specified authentication method.

## Related information

- [Authentication framework concepts](../concepts/auth-framework.mdx)
- [VirtualMCPServer configuration](./configuration.mdx)
- [Token exchange in Kubernetes](../guides-k8s/token-exchange-k8s.mdx)
