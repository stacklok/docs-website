---
title: 'Quickstart: Virtual MCP Server'
description:
  Learn how to aggregate multiple MCP servers into a single endpoint using
  Virtual MCP Server.
---

In this tutorial, you'll learn how to deploy Virtual MCP Server (vMCP) to
aggregate multiple MCP servers into a single endpoint. By the end, you'll have a
working deployment that combines tools from multiple backends.

## What you'll learn

- How to create an MCPGroup to organize backend servers
- How to deploy multiple MCPServers in a group
- How to create a VirtualMCPServer that aggregates them
- How tool conflict resolution works
- How to connect your AI client to the aggregated endpoint

## Prerequisites

Before starting this tutorial, make sure you have:

- A Kubernetes cluster with the ToolHive operator installed (see
  [Quickstart: Kubernetes Operator](./quickstart-k8s.mdx))
- `kubectl` configured to communicate with your cluster
- An MCP client (Visual Studio Code with Copilot is used in this tutorial)

## Step 1: Create an MCPGroup

First, create an MCPGroup to organize your backend MCP servers:

```yaml title="mcpgroup.yaml"
apiVersion: toolhive.stacklok.dev/v1alpha1
kind: MCPGroup
metadata:
  name: demo-tools
  namespace: toolhive-system
spec:
  description: Demo group for vMCP aggregation
```

Apply the resource:

```bash
kubectl apply -f mcpgroup.yaml
```

Verify the group was created:

```bash
kubectl get mcpgroups -n toolhive-system
```

## Step 2: Deploy backend MCPServers

Deploy two MCP servers that will be aggregated. Both reference the `demo-tools`
group in the `groupRef` field:

```yaml {11,30} title="mcpservers.yaml"
apiVersion: toolhive.stacklok.dev/v1alpha1
kind: MCPServer
metadata:
  name: fetch
  namespace: toolhive-system
spec:
  image: ghcr.io/stackloklabs/gofetch/server
  transport: streamable-http
  proxyPort: 8080
  mcpPort: 8080
  groupRef: demo-tools
  resources:
    limits:
      cpu: '100m'
      memory: '128Mi'
    requests:
      cpu: '50m'
      memory: '64Mi'
---
apiVersion: toolhive.stacklok.dev/v1alpha1
kind: MCPServer
metadata:
  name: osv
  namespace: toolhive-system
spec:
  image: ghcr.io/stackloklabs/osv-mcp/server
  transport: streamable-http
  proxyPort: 8080
  mcpPort: 8080
  groupRef: demo-tools
  resources:
    limits:
      cpu: '100m'
      memory: '128Mi'
    requests:
      cpu: '50m'
      memory: '64Mi'
```

Apply the resources:

```bash
kubectl apply -f mcpservers.yaml
```

Wait for both servers to be running:

```bash
kubectl get mcpservers -n toolhive-system -w
```

You should see both servers with `Running` status before continuing.

## Step 3: Create a VirtualMCPServer

Create a VirtualMCPServer that aggregates both backends:

```yaml title="virtualmcpserver.yaml"
apiVersion: toolhive.stacklok.dev/v1alpha1
kind: VirtualMCPServer
metadata:
  name: demo-vmcp
  namespace: toolhive-system
spec:
  # Reference the MCPGroup containing fetch and osv servers
  groupRef:
    name: demo-tools

  # No incoming auth for development (anonymous access)
  incomingAuth:
    type: anonymous

  # Auto-discover auth config from backend MCPServers
  outgoingAuth:
    source: inline
    # No default specified will use anonymous

  # Tool aggregation with prefix strategy to avoid naming conflicts
  aggregation:
    conflictResolution: prefix
    conflictResolutionConfig:
      prefixFormat: '{workload}_'

  # Expose as ClusterIP (cluster-internal or exposed via Ingress/Gateway)
  serviceType: ClusterIP
```

Apply the resource:

```bash
kubectl apply -f virtualmcpserver.yaml
```

Check the status:

```bash
kubectl get virtualmcpservers -n toolhive-system
```

After about 30 seconds, you should see output similar to:

```text
NAME        PHASE   URL                                                            BACKENDS   AGE   READY
demo-vmcp   Ready   http://vmcp-demo-vmcp.toolhive-system.svc.cluster.local:4483   2          30s   True
```

Note the port number for step 5.

:::info[What's happening?]

The operator discovered both MCPServers in the group and configured vMCP to
aggregate their tools. With the `prefix` conflict resolution strategy, all tools
are prefixed with the backend name.

:::

## Step 4: Verify the aggregation

Check the discovered backends:

```bash
kubectl describe virtualmcpserver demo-vmcp -n toolhive-system
```

Look for the `Discovered Backends` section in the status, which should show both
backends.

## Step 5: Connect your client

In a separate terminal, port-forward the vMCP service to your local machine:

```bash
kubectl port-forward service/vmcp-demo-vmcp -n toolhive-system 4483:4483
```

Test the health endpoint:

```bash
curl http://localhost:4483/health
```

You should see `{"status":"ok"}`.

Configure VS Code to connect to vMCP. Add the following to your `mcp.json` file:

- **macOS**: `~/Library/Application Support/Code/User/mcp.json`
- **Windows**: `%APPDATA%\Code\User\mcp.json`
- **Linux**: `~/.config/Code/User/mcp.json`

```json
{
  "servers": {
    "demo-vmcp": {
      "url": "http://localhost:4483/mcp",
      "type": "http"
    }
  }
}
```

Reload VS Code to apply the configuration.

:::tip

For other MCP clients, see the
[Client compatibility reference](../reference/client-compatibility.mdx) for
configuration file locations and formats.

:::

## Step 6: Test the aggregated tools

Try asking your AI assistant questions that use the aggregated tools. Both tools
work through the same vMCP endpoint!

## Step 7: Clean up

Delete the resources when you're done:

```bash
kubectl delete virtualmcpserver demo-vmcp -n toolhive-system
kubectl delete mcpserver fetch osv -n toolhive-system
kubectl delete mcpgroup demo-tools -n toolhive-system
```

## What's next?

Congratulations! You've successfully deployed vMCP and aggregated multiple
backends into a single endpoint.

Next steps:

- [Configure authentication](../guides-vmcp/authentication.mdx) for production
- [Customize tool aggregation](../guides-vmcp/tool-aggregation.mdx) with
  filtering and overrides
- [Understanding Virtual MCP Server](../concepts/vmcp.mdx)

## Troubleshooting

<details>
<summary>VirtualMCPServer stuck in Pending</summary>

Check that the MCPGroup exists and backend MCPServers are running:

```bash
kubectl get mcpgroups,mcpservers -n toolhive-system
```

Check the operator logs:

```bash
kubectl logs -n toolhive-system -l app.kubernetes.io/name=toolhive-operator
```

</details>

<details>
<summary>Only some tools appearing</summary>

Verify both backends are discovered:

```bash
kubectl get virtualmcpserver demo-vmcp -n toolhive-system -o jsonpath='{.status.discoveredBackends[*].name}'
```

Check backend health in the status:

```bash
kubectl describe virtualmcpserver demo-vmcp -n toolhive-system
```

</details>
