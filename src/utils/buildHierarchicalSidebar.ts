// SPDX-FileCopyrightText: Copyright 2025 Stacklok, Inc.
// SPDX-License-Identifier: Apache-2.0

import fs from 'fs';
import path from 'path';

// TypeScript interfaces for better type safety
interface CommandTreeNode {
  id: string;
  label: string;
  children: Map<string, CommandTreeNode>;
  hasFile: boolean;
}

interface SidebarItemDoc {
  type: 'doc';
  id: string;
  label?: string;
}

interface SidebarItemCategory {
  type: 'category';
  label: string;
  collapsed: boolean;
  items: SidebarItem[];
  link?: { type: 'doc'; id: string };
}

interface SidebarItemAutogenerated {
  type: 'autogenerated';
  dirName: string;
}

type SidebarItem =
  | SidebarItemDoc
  | SidebarItemCategory
  | SidebarItemAutogenerated;

interface HierarchicalSidebarOptions {
  /** Relative path to the directory containing markdown files */
  dirPath: string;
  /** ID prefix for generated sidebar items (e.g., 'toolhive/reference/cli') */
  idPrefix: string;
  /** Separator used in filenames to denote hierarchy (default: '_') */
  separator?: string;
  /** Whether categories should be collapsed by default (default: true) */
  collapsed?: boolean;
}

/**
 * Builds a hierarchical sidebar from flat markdown files with separator-delimited naming.
 *
 * Parses files with naming patterns like:
 * - tool.md -> "tool"
 * - tool_command.md -> "tool" > "command"
 * - tool_command_subcommand_action.md -> "tool" > "command" > "subcommand" > "action"
 *
 * Each level shows only the command name (not the full path), creating clean navigation.
 *
 * @param options Configuration options for building the sidebar
 * @returns Array of sidebar items with hierarchical structure
 *
 * @example
 * ```typescript
 * // For CLI reference docs
 * const cliSidebar = buildHierarchicalSidebar({
 *   dirPath: 'docs/toolhive/reference/cli',
 *   idPrefix: 'toolhive/reference/cli'
 * });
 *
 * // For API reference docs with different separator
 * const apiSidebar = buildHierarchicalSidebar({
 *   dirPath: 'docs/api/endpoints',
 *   idPrefix: 'api/endpoints',
 *   separator: '-'
 * });
 * ```
 */
export function buildHierarchicalSidebar(
  options: HierarchicalSidebarOptions
): SidebarItem[] {
  const { dirPath, idPrefix, separator = '_', collapsed = true } = options;

  const fullDirPath = path.join(process.cwd(), dirPath);

  try {
    const files = fs
      .readdirSync(fullDirPath)
      .filter((file) => file.endsWith('.md'))
      .map((file) => file.replace('.md', ''));

    // Build command tree
    const tree = new Map<string, CommandTreeNode>();

    for (const filename of files) {
      const parts = filename.split(separator);
      let current = tree;

      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const isLeaf = i === parts.length - 1;

        if (!current.has(part)) {
          current.set(part, {
            id: `${idPrefix}/${parts.slice(0, i + 1).join(separator)}`,
            label: part,
            children: new Map<string, CommandTreeNode>(),
            hasFile: false,
          });
        }

        const node = current.get(part)!;
        if (isLeaf) {
          node.hasFile = true;
        }
        current = node.children;
      }
    }

    // Convert tree to sidebar items
    function treeToItems(nodeMap: Map<string, CommandTreeNode>): SidebarItem[] {
      const items: SidebarItem[] = [];

      for (const [, node] of nodeMap) {
        if (node.children.size === 0) {
          // Leaf node
          items.push({
            type: 'doc',
            id: node.id,
            label: node.label,
          });
        } else {
          // Category with children
          const categoryItem: SidebarItemCategory = {
            type: 'category',
            label: node.label,
            collapsed,
            items: treeToItems(node.children),
          };

          // Link to main command page if it exists
          if (node.hasFile) {
            categoryItem.link = {
              type: 'doc',
              id: node.id,
            };
          }

          items.push(categoryItem);
        }
      }

      return items;
    }

    return treeToItems(tree);
  } catch (error) {
    console.warn(`Could not build hierarchical sidebar for ${dirPath}:`, error);
    // Fallback to autogenerated
    return [
      {
        type: 'autogenerated',
        dirName: dirPath,
      },
    ];
  }
}

/**
 * Convenience function for building CLI reference sidebars.
 *
 * @param dirPath Relative path to CLI documentation directory
 * @param idPrefix ID prefix for generated sidebar items
 * @returns Array of sidebar items with hierarchical structure
 */
export function buildCliReferenceSidebar(
  dirPath: string = 'docs/toolhive/reference/cli',
  idPrefix: string = 'toolhive/reference/cli'
): SidebarItem[] {
  return buildHierarchicalSidebar({
    dirPath,
    idPrefix,
    separator: '_',
    collapsed: true,
  });
}
